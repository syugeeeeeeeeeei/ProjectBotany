# 🏗️ Core-Feature アーキテクチャルール

## 1. 🏛️ アーキテクチャが守るべき思想

本プロジェクトは「**堅牢な OS（Core）**」と「**着脱可能なアプリケーション（Feature）**」の関係性を模倣したアーキテクチャを採用します。

- **Core の不変性と安定性**: Core はゲームの成立に不可欠な「土台」であり、Feature の存在に関わらず単体で動作可能でなければなりません。Feature の都合で Core を汚染してはなりません。
- **Feature の独立性と着脱性**: Feature はゲームを面白くするための「飾り」であり、いつでも削除・無効化が可能でなければなりません。Feature 同士は互いを知らず、疎結合であるべきです。
- **制御の反転（IoC）と宣言的記述**: Feature は自ら実行タイミングを制御せず、Core が発行するイベントに対して「何をしたいか」を宣言（Manifest）する形式をとります。
- **予測可能なデータフロー**: データの読み取り（Query）と書き込み（Command）を明確に分離し（CQRS）、どこで何が起きているかを追跡可能にします。

## 2. 🔗 依存関係のルール

階層構造を厳守し、循環参照やスパゲッティコードを防ぎます。

### 階層定義

- **Level 0: Shared (`src/shared/`)** - 全体で共有される「共通言語」。
- **Level 1: Core (`src/core/`)** - ゲームシステムの中核。
- **Level 2: Feature (`src/features/`)** - 個別の拡張機能。
- **Level 3: App (`src/app/`)** - すべてを統合する配線盤。

### Import ルール

| ディレクトリ | Import 許可 (✅)                     | Import 禁止 (🚫)                                    |
| ------------ | ------------------------------------ | --------------------------------------------------- |
| **Shared**   | 外部ライブラリのみ                   | `app`, `core`, `features` (上位層すべて)            |
| **Core**     | `shared`                             | `features` (**絶対禁止**), `app`                    |
| **Feature**  | `shared`, `core/api` (公開 API のみ) | `core/store` (内部実装), `features` (他機能), `app` |
| **App**      | すべて                               | なし                                                |

### 補足

- **Feature 間通信の禁止**: Feature A が Feature B を import してはいけません。連携が必要な場合は、Core のイベントを介して行うか、共有ロジックを `Shared` に切り出してください。
- **Core 内部隠蔽**: Feature は `core/store` や `core/systems` に直接アクセスしてはいけません。必ず `core/api` を経由してください。

## 3. 🔄 CQRS エコシステムの利用・修正ルール

状態管理（Zustand）を Core 内部に隠蔽し、Command（書き込み）と Query（読み取り）を分離して公開します。

### 利用ルール (Feature 開発者向け)

- **Query (Read)**:
- `useGameQuery` などの専用フックを使用してデータを取得してください。
- `useGameStore` を直接 `import` してはいけません。

- **Command (Write)**:
- `gameActions.field.mutateCell(...)` などの公開アクション関数を呼び出してください。
- Store の `setState` を直接叩くことは禁止です。

### 修正ルール (Core 開発者向け)

- **API の公開**: 新しい状態や操作が必要になった場合は、`src/core/api/queries.ts` または `actions.ts` にラッパー関数を追加して公開してください。
- **Atomic な操作**: Action は「セルのタイプを変える」「ターンを進める」といった最小単位（Atomic）の操作として定義し、複雑なゲームロジックを含めないようにしてください（ロジックは Feature または System が担います）。

## 4. ⚡️ EventDriven エコシステムの利用・修正ルール

ロジックの実行は関数呼び出しではなく、イベント駆動で行います。

### 利用ルール (Feature 開発者向け)

- **Manifest による宣言**: `src/features/[feature-name]/index.ts` で `FeatureManifest` を export し、リスナーを定義してください。
- **副作用の記述**: `listeners` 内のコールバック関数で、Core API (`actions`) を呼び出して副作用（ゲーム状態の変更）を起こしてください。
- **UI の注入**: `RENDER_CELL_OVERLAY` などの UI 系イベントに対し、React Node を返すことで画面描画に介入してください。

### 修正ルール (Core 開発者向け)

- **イベント定義**: 新しいフックポイントが必要な場合は、`src/core/types/events.ts` の `CoreEventMap` に定義を追加してください。
- **発火ポイント**: `GameEventBus.emit()` を適切なタイミング（`systems` 内など）に埋め込んでください。
- **型安全性**: イベントのペイロード（引数）は厳密に型定義し、`any` を避けてください。

## 5. 🛠️ Core/Feature を編集するときのルール

### Core を編集するとき

- **汎用性の維持**: 「特定のカードのためだけの処理」など、特定の Feature に依存したロジックを Core に書いてはいけません。Core はあくまで「ルールエンジン」です。
- **後方互換性**: 公開 API (`actions`, `queries`) のシグネチャを変更する際は、既存の Feature が壊れないよう注意してください。

### Feature を編集するとき

- **自己完結**: その機能に必要なロジック、UI、定数はすべて `src/features/[feature-name]/` 内に閉じてください。
- **クリーンアップ**: 不要になった Feature ディレクトリを削除すれば、きれいに機能が消える状態を保ってください。
- **Local State**: Feature 内でのみ完結する UI 状態（ドラッグ中の位置など）は、React の `useState` などで管理し、Core の Global Store に入れないでください。

---

## 6. 🚀 ゲームに新たな機能を追加するときのフロー

**(Case A: Feature のみで完結するケース - 既存の API/イベントで足りる場合)**

1. **ディレクトリ作成**: `src/features/` 配下に機能名でディレクトリを作成（例: `poison-swamp`）。
2. **ロジック実装**: `logic.ts` を作成し、イベントリスナー関数（毒ダメージ計算など）を実装。

- _Check_: 必要な情報は `useGameQuery` で取れるか？ 操作は `gameActions` で可能か？

3. **UI 実装**: 必要なら `ui/` 配下にコンポーネントを作成。
4. **Manifest 作成**: `index.ts` で `FeatureManifest` を定義し、ロジックと UI を紐付ける。優先度（Priority）を適切に設定する。
5. **登録**: `src/app/FeaturesRegistry.ts` (または `GameComposition.ts`) に追加して有効化。
6. **確認**: ゲームを起動し、機能が動作することを確認。

## 7. 🔧 ゲームに新たな機能を追加するときのフロー

**(Case B: Core の修正が必要なケース - 新しいイベントや API が必要な場合)**

1. **要件の抽出**: Feature の実装に必要な「情報」や「操作」が Core に不足していることを確認。
2. **Core 修正 (API/Event)**:

- **イベント追加**: `src/core/types/events.ts` にイベント型を追加し、Core 内の適切な場所で `emit` する。
- **API 追加**: `src/core/store` に状態を追加し、`src/core/api` にそれを読み書きする Query/Action を追加する。

3. **Core テスト**: Feature がない状態でも Core が正常に動作し、エラーが出ないことを確認。
4. **Feature 実装**: 追加された API/イベントを使用して、Case A の手順で Feature を実装。
5. **レビュー**: Core への変更が「汎用的」であるか（その Feature 専用になっていないか）を重点的にレビュー。
