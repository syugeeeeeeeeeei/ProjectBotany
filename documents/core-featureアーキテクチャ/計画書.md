# 🏗️ Core-Feature アーキテクチャ改修計画書

## 1. 既存のアーキテクチャの問題

現在の「Feature-based Registry (v1)」には、以下の構造的な欠陥があります。

- **⚠️ 必須機能の不安定なプラグイン化**
- `field-grid`（盤面）や `turn-system`（進行）など、ゲーム成立に不可欠な機能まで Feature として扱われている。
- これらが `config.ts` で `false` に設定できてしまい、設定ミスでゲームが進行不能になるリスクがある。

- **🍝 依存性のスパゲッティ化**
- Feature 間の横方向の依存（例: カード機能が盤面データを知る必要がある）を回避するために Registry を導入したが、実体が見えなくなり「何がどこに依存しているか」が追跡困難になっている。

- **🔄 依存方向の逆転（下から上への参照）**
- 下位レイヤーである Feature が、上位レイヤー（App 層）にある `ActionRegistry` や `InteractionRegistry` を `import` して書き換えに行っている（自己登録パターン）。これは循環参照の温床となる。

## 2. 新規アーキテクチャ Core-Feature の詳細解説

システムを「変えてはいけない土台（Core）」と「変えてもいい部品（Feature）」に物理的に分離します。

### 🧠 Core (System / Kernel)

**定義:** Feature をすべて削除しても、ゲームの開始・進行・終了をつつがなく行うことができるシステム領域。

- **役割:**
- **Headless Logic:** UI を持たない（またはデバッグ用の簡易 UI のみ持つ）純粋なロジック。
- **State Management:** `GameState`, `CellState` などの真実のデータ（Source of Truth）を管理。
- **Event Bus:** `TURN_START`, `CELL_CLICK` などのイベントを発行するハブ。
- **Atomic API:** `mutateCell`, `scheduleTask` などの最小単位の操作命令セットを提供。

- **配置:** `src/core/`

### 🎨 Feature (Extension / Plugin)

**定義:** Core の上で動作し、ゲームの面白さやリッチな体験を提供する拡張機能。

- **役割:**
- **Rich UI:** `Hand3D`, `GameBoard3D` などの具体的な表示物を Core のスロットに注入。
- **Specific Rules:** 「外来種の侵食」「カード効果」などの具体的なゲームルール。
- **Manifest:** 自身がリッスンしたいイベントや優先度を定義した静的オブジェクトを `export` する。

- **配置:** `src/features/`

### 🤝 Shared (Library)

**役割:** Core と Feature の両方から参照される共通の「型」や「計算ロジック」。

- **内容:** `Targeting.getCircle()`（範囲計算）、共通 UI コンポーネント（`Outline`）など。

## 3. Core-Feature の既存の問題への対応

| 問題点             | 解決策                                                                                                                                                                       |
| ------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **必須機能の OFF** | **Core への完全移管。** 必須機能は Feature フラグ管理から除外され、常に存在するシステムとなる。                                                                              |
| **スパゲッティ化** | **Core API の提供。** Feature は他の Feature を直接参照せず、Core が提供する API（`core.field.mutate` 等）と Shared（計算ロジック）のみを使用する。                          |
| **逆方向の依存**   | **Manifest 方式（Pull 型）の採用。** Feature は「定義データ」を `export` するだけ。上位レイヤー（App）がそれを `import` してシステムに登録する「一方通行」の依存関係にする。 |

## 4. Core-Feature で追加するライブラリ

イベント駆動アーキテクチャを実現するために、軽量なイベントライブラリを導入します。

- **ライブラリ名:** **`mitt`**
- **選定理由:** 極小サイズ（~200byte）、TypeScript との親和性（型安全）、高パフォーマンス。
- **実装方針:** 生の `mitt` を直接使わず、Core 内でラップクラスを作成して使用する。

```typescript
// Core内での実装イメージ
import mitt from "mitt";
import { CoreEventMap } from "@/core/types/events";

export class GameEventBus {
  private emitter = mitt<CoreEventMap>();

  // 型安全なラップメソッド
  emit<K extends keyof CoreEventMap>(key: K, data: CoreEventMap[K]) {
    console.debug(`[Event] ${key}`, data); // デバッグログも挟める
    this.emitter.emit(key, data);
  }
  // on, off ...
}
```

## 5. Core-Feature を使ったゲーム作成方法の変更点

開発スタイルは「命令的（手続き的）」から**「宣言的（イベント駆動）」**へ変化します。

### ① Manifest による機能宣言

`init()` 関数で動的に登録するのではなく、静的なオブジェクトを定義します。

```typescript
// features/alien-expansion/index.ts
export const alienExpansionFeature: FeatureManifest = {
  key: "alien-expansion",
  priority: 100, // 実行順序の制御
  listeners: {
    TURN_START: (state) => {
      /* 侵食ロジック */
    },
  },
};
```

### ② Core API を使った Atomic Action

Feature は `store` を直接書き換えるのではなく、Core が提供する API を叩きます。

- **旧:** `store.cells[y][x].type = "wasteland"` (直接書き換え)
- **新:** `core.field.mutateCell(x, y, "wasteland")` (API 経由)

### ③ イベント駆動による疎結合

「A が起きたら B をする」を直接繋ぐのではなく、イベントを介して連携します。

- **フロー:**

1. Core: 「ターン終了ボタンが押された」→ `emit("BEFORE_TURN_END")`
2. Feature A (侵食): イベントを検知 → 侵食処理を実行
3. Feature B (毒): イベントを検知 → ダメージ処理を実行
4. Core: 全処理完了後 → `currentTurn` を進める

### ④ UI の注入 (Slot Pattern)

Core は「枠」だけを用意し、Feature が「中身」を返します。

- **Core:** `emit("RENDER_OVERLAY", cell)` で各 Feature に問い合わせる。
- **Feature:** 「私はここにアウトラインを出したい」と React Node を返す。

## 6. 📂 具体的なディレクトリ構成案

「機能単位」ではなく「役割単位」で Core を構成し、Feature は「プラグイン単位」で構成します。

```text
src/
├── core/                        # 🧠 KERNEL: ゲームのOS部分
│   ├── store/                   # 状態管理の実体 (Zustand)
│   │   ├── gameStore.ts         # GameState (Source of Truth)
│   │   └── uiStore.ts           # Global UI State (選択状態など)
│   ├── event-bus/               # イベント通信網
│   │   ├── GameEventBus.ts      # mittラッパー
│   │   └── events.ts            # CoreEventMap (型定義)
│   ├── systems/                 # ゲームループ・ロジック
│   │   ├── TurnSystem.ts        # ターン進行管理
│   │   └── FieldSystem.ts       # 盤面操作ロジック
│   ├── api/                     # 🚪 PUBLIC API: Featureとの唯一の接点
│   │   ├── actions.ts           # (Write) mutateCell, endTurn などの操作命令
│   │   └── queries.ts           # (Read) useCell, useCurrentTurn などの参照フック
│   └── ui/                      # Headless / Default UI
│       ├── GameLayout.tsx       # 画面の枠組み (Slot提供)
│       └── DefaultBoard.tsx     # Featureがない時の盤面描画
│
├── features/                    # 🎨 PLUGINS: 拡張機能
│   ├── alien-expansion/         # 例: 外来種侵食機能
│   │   ├── index.ts             # Manifest (export definition)
│   │   ├── logic.ts             # イベントリスナー
│   │   └── config.ts            # パラメータ定数
│   ├── play-card/               # 例: カード使用機能
│   │   ├── index.ts             # Manifest
│   │   ├── ui/                  # UIコンポーネント
│   │   │   ├── ActionButtons.tsx
│   │   │   └── PreviewPiece.tsx
│   │   └── logic/               # ロジック
│   │       └── cardEffects.ts
│   └── ...
│
├── shared/                      # 📚 LIBRARY: 共通部品
│   ├── types/                   # 全体で使う型
│   │   ├── gameState.ts         # GameState, CellState
│   │   └── primitives.ts        # Point, Vector3
│   ├── utils/                   # 純粋関数
│   │   ├── targeting.ts         # 範囲計算 (getCircle, getLine)
│   │   └── randomization.ts     # 乱数生成
│   └── components/              # ステートレスなUI部品
│       ├── Outline.tsx          # 3D枠線
│       └── Button.tsx           # 共通ボタン
│
└── app/                         # 🔌 WIRING: 配線盤
    ├── GameComposition.ts       # FeatureをimportしてCoreに登録する場所
    ├── App.tsx                  # Reactエントリポイント
    └── main.tsx

```

## 7. 🔄 State 管理と API 戦略 (CQRS)

Feature からの直接的な `store` 操作を禁止し、**CQRS (Command Query Responsibility Segregation)** パターンを導入します。

### ① UI State と Game State の分離

- **Game State (Core):** 「盤面」「HP」など全機能共有の真実。`core/store` で管理。
- **Global UI State (Core):** 「選択中のセル」など共有が必要な UI 状態。`core/api` 経由で公開。
- **Local UI State (Feature):** 「ドラッグ中の座標」などその機能だけの状態。Feature 内で `useState` 等で完結させる。

### ② API 経由でのアクセス (Code Example)

Feature は Zustand の存在を知らず、Core が提供する `actions` (コマンド) と `queries` (クエリ) のみを使用します。

```typescript
// Feature内での実装例
import { gameActions, useGameQuery } from "@/core/api"; // これだけをimport

const MyFeatureComponent = () => {
  // Read: 専用フックで値を取得
  const currentTurn = useGameQuery.useCurrentTurn();

  const handleClick = () => {
    // Write: アクション経由で変更を依頼
    gameActions.field.mutateCell(0, 0, "wasteland");
  };
};
```

## 8. 🛡️ ESLint によるアーキテクチャの強制

「うっかり依存」を物理的に防ぐため、`eslint-plugin-import` の `no-restricted-paths` を導入します。

### 導入ルール

1. **Core の保護:** `src/core` は `src/features` を import してはならない。
2. **Shared の純粋化:** `src/shared` は `src/app`, `src/core`, `src/features` を import してはならない。
3. **Feature 間の独立:** `src/features/*` は他の `src/features/*` を import してはならない（`shared` か `core` を経由する）。

---

## 9. ⛑️ 安全なリファクタリング移行手順

システムやデザイン（定数値など）を壊さずに移行するための、5 段階のフェーズプランです。

### Phase 1: 共通基盤の切り出し (Non-Destructive)

まずは既存コードを壊さず、移動できるものを移動します。

1. `src/shared` ディレクトリを作成。
2. 型定義（`types/`）、定数（`constants/`）、ユーティリティ（`utils/`）を `src/shared` へ移動。
3. 既存の import パスを修正し、アプリが起動することを確認。
4. **重要:** デザインに関わる定数（色、サイズなど）もここで `shared/constants/design-tokens.ts` 等に集約し、後の UI 移動時の崩れを防ぐ。

### Phase 2: Core の確立 (The Surgery)

「必須機能」を物理的に分離します。一時的に Feature が動かなくなっても、Core 単体で動くことを目指します。

1. `src/core` を作成し、Zustand Store (`useGameStore`) を移動。
2. `field-grid`, `turn-system` のロジック部分を `core/systems` へ移植。
3. **API 層の作成:** Feature が使う予定の `core/api/actions.ts` と `queries.ts` を作成し、既存の Store 操作をラップする。
4. この時点で、Feature を全て OFF にした状態で「空の盤面」と「ターン経過」が動くことを確認（Headless test）。

### Phase 3: イベントバスの敷設

Core と Feature をつなぐ神経網を作ります。

1. `mitt` を導入し、`core/event-bus/GameEventBus.ts` を実装。
2. Core 内の主要箇所（ターン開始時など）に `emit('TURN_START')` を埋め込む。
3. まだ誰もリッスンしていないので、挙動は変わらないはず。

### Phase 4: Feature の順次移植

既存の Feature を一つずつ新アーキテクチャに適合させます。

1. **依存の解消:** Feature 内のコードから `useGameStore` の直接参照を消し、Phase 2 で作った `core/api` に置き換える。
2. **Manifest 化:** `init()` 関数を廃止し、`index.ts` で `FeatureManifest` を export する形に書き換える。
3. **Wiring:** `app/GameComposition.ts` に import し、動作確認。
4. これを 1 機能ずつ行う（PlayCard → AlienExpansion...）。

### Phase 5: 制限の適用 (Cleanup)

最後に「足場」を外してルールを厳格化します。

1. 古い `Registry` システムを削除。
2. ESLint のルール（Section 8）を有効化し、違反がないかチェック。
3. `app/config.ts` などの古い設定ファイルを削除。
